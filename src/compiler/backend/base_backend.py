# MetaForge Compiler - Base Backend
#
# Copyright (c) 2025 SeregonWar (https://github.com/SeregonWar)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# ---------------------------------------------------------------------------------
# Project: MetaForge Compiler
# Module: Base Backend
# Author: SeregonWar (https://github.com/SeregonWar)
# License: MIT License
#
# Description:
# This module provides a base class for compiler backends, which are
# responsible for generating target-specific code from the intermediate
# representation (IR) generated by the compiler.
#
# Key Features:
# - Provides a common interface for all compiler backends.
# - Defines the structure of a compiler backend.
# - Allows for easy extension of the compiler with new backends.
#
# Usage & Extensibility:
# To use this module, create a new class that inherits from BaseBackend.
# Implement the abstract methods in this class to create a new backend.
# Once the new backend is complete, it can be used like any other backend.
#
# ---------------------------------------------------------------------------------
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import List, Dict, Optional
from pathlib import Path

class Platform(Enum):
    WINDOWS = "windows"
    LINUX = "linux"
    MACOS = "macos"
    PLAYSTATION = "playstation"

class Architecture(Enum):
    X86 = "x86"
    X64 = "x64"
    ARM = "arm"
    ARM64 = "arm64"

class BinaryFormat(Enum):
    PE = "pe"      # Windows
    ELF = "elf"    # Linux
    MACHO = "mach-o" # macOS

@dataclass
class BackendOptions:
    platform: Platform
    architecture: Architecture
    binary_format: BinaryFormat
    debug_info: bool = False
    pic: bool = False  # Position Independent Code
    optimize_level: int = 0
    target_cpu: Optional[str] = None
    cpu_features: List[str] = None

class CompilerBackend(ABC):
    """Base class for compiler backends"""
    
    def __init__(self, options: BackendOptions):
        self.options = options
        
    @abstractmethod
    def compile(self, ir: Dict, output_file: Path) -> bool:
        """Compile IR to target binary format"""
        if not self.supports_platform(self.options.platform):
            return False
            
        if not self.supports_architecture(self.options.architecture):
            return False
            
        return True
        
    @abstractmethod
    def supports_platform(self, platform: Platform) -> bool:
        """Check if backend supports a platform"""
        return platform in [Platform.WINDOWS, Platform.LINUX, Platform.MACOS]
        
    @abstractmethod
    def supports_architecture(self, arch: Architecture) -> bool:
        """Check if backend supports an architecture"""
        return arch in [Architecture.X64, Architecture.X86]
        
    @abstractmethod
    def get_file_extension(self) -> str:
        """Get file extension for this backend"""
        if self.options.platform == Platform.WINDOWS:
            return ".obj"
        elif self.options.platform == Platform.LINUX:
            return ".o"
        elif self.options.platform == Platform.MACOS:
            return ".o"
        return ".o"